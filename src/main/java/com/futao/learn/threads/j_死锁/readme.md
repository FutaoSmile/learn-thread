### # 死锁
* 什么是死锁
    * 发生在并发中
    * 两个或多个线程互相持有对方所需要的资源，但又不主动释放，导致几个线程都陷入无限等待的过程中，这就是死锁。
* 危害 


#### 死锁发生的4个必要条件(缺一不可)
* 互斥条件
    * 一个资源只能被一个线程所持有
* 请求与保持
    * 线程1请求第二把锁，但是同时保持第一把锁
* 不剥夺条件
    * 外界干扰，剥夺，终止一个线程
* 循环等待条件

#### # 定位死锁
* JDK工具
    * 获取到进程的PID：JDK工具：`jps`
    * 查看线程信息: JDK工具：`jstack PID`
* 代码
    ThreadMXBean
    
#### # 解决死锁
* 按顺序获取锁，不要按相反的顺序获取锁
* 避免策略，编写程序时避免发生死锁
* 检测与恢复： 检测(可以使用定时任务检测ThreadMXBean)到死锁发生后，剥夺某个线程的某个资源
* 鸵鸟策略，如果发生的概率很低，就直接忽略它，知道死锁死锁发生，再人工修复
    
### # 避免死锁
* 设置超时时间
* 使用Lock.tryLock(lo ng timeout,TimeUnit timeUnit) ，synchronized不具备超时能力
* 多使用并发类，而不是自己实现
* 尽量降低锁的粒度
* 避免锁的嵌套
* 不要几个功能使用同一把锁
    
#### # 活锁问题
* 线程虽然没有阻塞，也始终在运行，但是程序却得不到进展，因为线程始终在做同样的事情。
* 解决活锁：引入随机值